# ====== SERVER ======
spring.application.name=backend
server.port=8080

# ====== SPRING DEVTOOLS (HOT RELOAD) ======
# üî• Enable DevTools restart on file changes
spring.devtools.restart.enabled=true
# üê≥ IMPORTANT: Use polling for Docker volume mounts (file events don't work in Docker)
spring.devtools.restart.poll-interval=1000
spring.devtools.restart.quiet-period=500
# üìÅ Watch these directories for changes
spring.devtools.restart.additional-paths=src/main/java,src/main/resources
# ‚ö° Faster restart by excluding static resources
spring.devtools.restart.exclude=static/**,public/**

# ====== DATASOURCE (Postgres) ======
spring.datasource.url=jdbc:postgresql://db:5432/core
spring.datasource.username=core
spring.datasource.password=core
# Disable Hibernate auto-DDL - we use Flyway for schema management
# Hibernate DDL
# IMPORTANT: Must be 'none' to let Flyway handle all schema changes
# 'validate' would fail if Flyway hasn't run yet (chicken-egg problem)
spring.jpa.hibernate.ddl-auto=none

# ====== KEYCLOAK DATASOURCE (for change_events polling) ======
keycloak.datasource.url=jdbc:postgresql://db:5432/keycloak
keycloak.datasource.username=${KEYCLOAK_DB_USERNAME:keycloak}
keycloak.datasource.password=${KEYCLOAK_DB_PASSWORD:keycloak}
keycloak.datasource.driver-class-name=org.postgresql.Driver

# ====== FLYWAY MIGRATION ======
# CRITICAL: Spring Boot auto-config DISABLED - runs too late (after JPA)
# Migrations run in FlywayConfig @PostConstruct (before JPA initialization)
spring.flyway.enabled=false
# spring.flyway.locations=classpath:db/migration  # Managed by FlywayConfig
# spring.flyway.baseline-on-migrate=true  # Managed by FlywayConfig

# ====== MULTITENANCY CONFIGURATION ======
tenancy.default-tenant-key=${TENANCY_DEFAULT_TENANT_KEY:test-tenant}
auth.jwt.tenant-claim=${AUTH_JWT_TENANT_CLAIM:tenant}

# ====== DYNAMIC JWT DECODER CONFIGURATION ======
# üîê DYNAMIC ISSUERS: Podporuje tenant-specific realms
# - admin: https://admin.core-platform.local/realms/admin  
# - ivigee: https://ivigee.core-platform.local/realms/ivigee
# - acme: https://acme.core-platform.local/realms/acme

# Base domain for constructing tenant-specific issuer URIs
security.oauth2.base-domain=${DOMAIN:core-platform.local}

# Audience for JWT validation (same for all tenants)
security.oauth2.audience=${OIDC_API_AUDIENCE:api}

# ‚ùå REMOVED: Static issuer configuration no longer needed
# spring.security.oauth2.resourceserver.jwt.issuer-uri=...
# spring.security.oauth2.resourceserver.jwt.jwk-set-uri=...

# ====== OAUTH2 CLIENT CONFIGURATION ======
# üîë OAuth2 klient pro backend - extern√≠ URL (pro redirecty)
# POZN√ÅMKA: Toto je pro OAuth2 flow, ne pro JWT validaci
spring.security.oauth2.client.registration.keycloak.client-id=core-backend
spring.security.oauth2.client.registration.keycloak.client-secret=${KEYCLOAK_CLIENT_SECRET}
spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak.redirect-uri=https://admin.${DOMAIN:core-platform.local}/api/auth/callback

# üîë Keycloak provider - extern√≠ URLs (pro OAuth2 flow)
# POZN√ÅMKA: Toto je pouze pro admin realm
spring.security.oauth2.client.provider.keycloak.authorization-uri=https://admin.${DOMAIN:core-platform.local}/realms/admin/protocol/openid-connect/auth
spring.security.oauth2.client.provider.keycloak.token-uri=https://admin.${DOMAIN:core-platform.local}/realms/admin/protocol/openid-connect/token
spring.security.oauth2.client.provider.keycloak.user-info-uri=https://admin.${DOMAIN:core-platform.local}/realms/admin/protocol/openid-connect/userinfo
spring.security.oauth2.client.provider.keycloak.jwk-set-uri=https://admin.${DOMAIN:core-platform.local}/realms/admin/protocol/openid-connect/certs
spring.security.oauth2.client.provider.keycloak.user-name-attribute=preferred_username

# ====== CORS Configuration ======
cors.origins=${CORS_ORIGINS:https://*.${DOMAIN:core-platform.local},https://${DOMAIN:core-platform.local},http://localhost}

# üîê Keycloak Admin Service - INTERN√ç Docker s√≠≈• (pouze pro admin REST API)
keycloak.admin.base-url=${KEYCLOAK_ADMIN_BASE_URL:http://keycloak:8080}
keycloak.admin.realm=${KEYCLOAK_ADMIN_REALM:master}
keycloak.admin.client-id=${KEYCLOAK_ADMIN_CLIENT_ID:backend-admin-service}
keycloak.admin.client-secret=${KEYCLOAK_ADMIN_CLIENT_SECRET}
keycloak.target-realm=${KEYCLOAK_TARGET_REALM:core-platform}

# üîê Master realm credentials for realm management (create/delete realms)
keycloak.master.username=${KEYCLOAK_MASTER_USERNAME:admin}
keycloak.master.password=${KEYCLOAK_MASTER_PASSWORD:admin123}

# üîê Samostatn√© nastaven√≠ pro backend Keycloak komunikaci
keycloak.base-url=http://keycloak:8080
keycloak.realm=core-platform
keycloak.client-id=web
keycloak.token-scopes=openid profile email

# ====== TENANT MANAGEMENT CONFIGURATION ======
app.tenant.auto-add-hosts=${TENANT_AUTO_ADD_HOSTS:true}
app.tenant.auto-create-realm=${TENANT_AUTO_CREATE_REALM:true}

# ====== LOGGING ======
logging.level.org.springframework.security=DEBUG
logging.level.org.springframework.security.oauth2=DEBUG
logging.level.org.springframework.security.oauth2.server.resource=DEBUG
logging.level.org.springframework.security.web.access.intercept=DEBUG
logging.level.cz.muriel.core=DEBUG
# ‚úÖ P≈òID√ÅNO: Debug pro UserProfileController JWT claims
logging.level.cz.muriel.core.controller.UserProfileController=DEBUG
# üè¢ P≈òID√ÅNO: Debug pro tenant komponenty
logging.level.cz.muriel.core.tenant=DEBUG
# üîê P≈òID√ÅNO: Debug pro dynamic JWT decoder
logging.level.cz.muriel.core.auth.config.DynamicJwtDecoder=DEBUG
# üîß CRITICAL: Debug pro Flyway migrations
logging.level.org.flywaydb=DEBUG

# ====== KEYCLOAK BACKFILL POLLING CONFIGURATION ======
# üîÑ Polling mechanismus pro backfill u≈æivatel≈Ø z Keycloaku
app.keycloak.backfill.enabled=${KEYCLOAK_BACKFILL_ENABLED:false}
app.keycloak.backfill.polling-interval-seconds=${KEYCLOAK_BACKFILL_POLLING_INTERVAL:5}
app.keycloak.backfill.batch-size=${KEYCLOAK_BACKFILL_BATCH_SIZE:10}
app.keycloak.backfill.users-per-tenant=${KEYCLOAK_BACKFILL_USERS_PER_TENANT:100}

# ====== KEYCLOAK ADMIN API CONFIGURATION ======
app.keycloak.admin.base-url=${KEYCLOAK_ADMIN_BASE_URL:http://keycloak:8080}
app.keycloak.admin.realm=${KEYCLOAK_ADMIN_REALM:master}
app.keycloak.admin.client-id=${KEYCLOAK_ADMIN_CLIENT_ID:admin-cli}
app.keycloak.admin.username=${KEYCLOAK_ADMIN_USERNAME:admin}
app.keycloak.admin.password=${KEYCLOAK_ADMIN_PASSWORD:admin}

# ====== KEYCLOAK ADMIN CLIENT FOR GRAFANA USER SYNC ======
keycloak.auth-server-url=${KEYCLOAK_ADMIN_BASE_URL:http://keycloak:8080}
keycloak.admin.realm=${KEYCLOAK_ADMIN_REALM:master}
keycloak.admin.client-id=${KEYCLOAK_ADMIN_CLIENT_ID:backend-admin-service}
keycloak.admin.client-secret=${KEYCLOAK_ADMIN_CLIENT_SECRET}

# ====== MONITORING FEATURE FLAGS ======
# üéõÔ∏è Feature toggles for monitoring stack migration
monitoring.grafana.enabled=${MONITORING_GRAFANA_ENABLED:false}
monitoring.loki.enabled=${MONITORING_LOKI_ENABLED:true}

# ====== LOKI INTEGRATION ======
# üìä Loki HTTP API for native monitoring UI
loki.url=${LOKI_URL:http://loki:3100}
loki.query.timeout=${LOKI_QUERY_TIMEOUT:30s}
loki.query.max-entries=${LOKI_QUERY_MAX_ENTRIES:5000}

# ====== GRAFANA INTEGRATION (DEPRECATED - to be removed) ======
# ‚ö†Ô∏è WARNING: Grafana FE integration is deprecated and will be removed
# These settings are kept for backward compatibility only
# Use monitoring.grafana.enabled=true to temporarily enable
# üìä Grafana Admin API pro user sync
grafana.url=${GRAFANA_URL:http://grafana:3000}
grafana.admin.user=${GRAFANA_ADMIN_USER:admin}
grafana.admin.password=${GRAFANA_ADMIN_PASSWORD:admin}

# üîê Grafana JWT SSO configuration (RS256) - DEPRECATED
# TTL: MUST match Keycloak access token lifespan (300s = 5 min)
# Grafana verifies BFF JWT via JWKS endpoint (/.well-known/jwks.json)
# Grafana cache TTL should match or be lower (see GF_AUTH_JWT_CACHE_TTL)
grafana.jwt.ttl=${GRAFANA_JWT_TTL:300}
# Legacy HMAC secret (not used with RS256, kept for backward compatibility)
grafana.jwt.secret=${GRAFANA_JWT_SECRET:change-me-in-production-to-secure-random-256bit-key}

# ÔøΩüîÑ POSTGRES TRIGGER SYNC CONFIGURATION - OPTIMIZED
# Database trigger synchronization system
app.change-events.flush-interval-seconds=10
app.change-events.batch-size=100
app.change-events.fallback-interval-seconds=60
app.change-events.cleanup-cron=0 30 2 * * *
app.change-events.listener-enabled=true

# üöÄ NOV√â OPTIMALIZACE V4
app.change-events.max-buffer-size=500
app.change-events.reconnect-delay-seconds=5
app.change-events.delete-batch-size=1000

# Spring Boot Actuator - Monitoring and Metrics
management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.endpoint.health.show-details=always
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true

# Custom application metrics
# Custom application metrics
management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.metrics.distribution.slo.http.server.requests=50ms,100ms,200ms,300ms,500ms,1s

# ====== REDIS CONFIGURATION (Phase 2) ======
spring.data.redis.host=${REDIS_HOST:redis}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.timeout=2000
spring.data.redis.lettuce.pool.max-active=10
spring.data.redis.lettuce.pool.max-idle=5
spring.data.redis.lettuce.pool.min-idle=1

# Cache configuration
spring.cache.type=redis
spring.cache.redis.time-to-live=600000
spring.cache.redis.cache-null-values=false

# ====== WEBSOCKET CONFIGURATION (Phase 2) ======
app.websocket.allowed-origins=${WEBSOCKET_ALLOWED_ORIGINS:https://*.core-platform.local,http://localhost:*}
app.websocket.heartbeat-interval-seconds=10
app.websocket.presence-ttl-seconds=30
app.websocket.rate-limit-events-per-window=10
app.websocket.rate-limit-window-seconds=5

# ====== MINIO CONFIGURATION (Phase 2) ======
minio.endpoint=${MINIO_ENDPOINT:http://minio:9000}
minio.access-key=${MINIO_ACCESS_KEY:minioadmin}
minio.secret-key=${MINIO_SECRET_KEY:minioadmin}
minio.bucket-prefix=${MINIO_BUCKET_PREFIX:tenant}
minio.versioning-enabled=true
minio.presigned-url-expiry-seconds=3600

# ====== DOCUMENT & FULLTEXT CONFIGURATION (Phase 2) ======
app.documents.max-upload-size-mb=50
app.documents.allowed-content-types=application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,text/plain,text/html
app.fulltext.max-results=100
app.fulltext.min-query-length=3

# ====== JOOQ CONFIGURATION (Phase 2) ======
spring.jooq.sql-dialect=POSTGRES

# ====== PAGINATION CONFIGURATION (Phase 2) ======
app.pagination.default-page-size=20
app.pagination.max-page-size=100
app.pagination.keyset-enabled=true

# ====== METAMODEL SCHEMA GENERATION ======
# üî® Enable automatic schema generation from YAML (EXPERIMENTAL)
# WARNING: This will CREATE/ALTER tables based on metamodel/*.yaml files
metamodel.schema.auto-generate=${METAMODEL_SCHEMA_AUTO_GENERATE:false}

# ====== STREAMING & KAFKA CONFIGURATION ======
streaming.enabled=${STREAMING_ENABLED:false}
streaming.kafka.servers=${KAFKA_SERVERS:kafka:9092}
streaming.topic.prefix=${STREAMING_TOPIC_PREFIX:core}
streaming.security.mode=${STREAMING_SECURITY_MODE:PLAINTEXT}
streaming.prometheus.port=${PROMETHEUS_PORT:9090}
streaming.grafana.public-url=${GRAFANA_PUBLIC_URL:https://grafana.core-platform.local}

# üîß Spring Boot Kafka defaults (used when streaming.enabled=false)
# These are needed for Kafka listeners that are NOT conditional on streaming.enabled
spring.kafka.bootstrap-servers=${KAFKA_SERVERS:kafka:9092}
spring.kafka.consumer.group-id=core-platform
spring.kafka.consumer.enable-auto-commit=false

# ====== MONITORING BFF CONFIGURATION ======
# üìä Grafana BFF Proxy - NO tokens exposed to browser
monitoring.grafana.base-url=${GRAFANA_BASE_URL:http://grafana:3000}
monitoring.grafana.max-body-size=10485760
monitoring.grafana.connect-timeout=5000
monitoring.grafana.read-timeout=30000
monitoring.grafana.write-timeout=30000

# üîê Tenant-to-Org mapping (load from Vault in production!)
# Format: {"tenant1":{"orgId":1,"token":"sat_xxx"},"tenant2":{"orgId":2,"token":"sat_yyy"}}
monitoring.tenant-org-map=${MONITORING_TENANT_ORG_MAP:{}}

# ====== CUBE.JS PRE-AGGREGATION WORKER ======
# üîÑ Kafka-driven pre-aggregation refresh
app.cube.preagg.enabled=${CUBE_PREAGG_ENABLED:true}
app.cube.preagg.debounceMs=${CUBE_PREAGG_DEBOUNCE_MS:30000}
app.cube.preagg.timeout=${CUBE_PREAGG_TIMEOUT_MS:30000}

# ====== CUBE.JS MODELGEN (Metamodel ‚Üí Cube Schema) ======
# üèóÔ∏è Auto-generate Cube.js schemas from metamodel
app.cube.schema.output-dir=${CUBE_SCHEMA_OUTPUT_DIR:docker/cube/schema}
app.cube.schema.auto-export=${CUBE_SCHEMA_AUTO_EXPORT:false}

# ====== KAFKA RETRY POLICIES ======
# üîÑ Standardized retry policies for Kafka consumers (S7)
# CRITICAL: User CRUD, payments, auth (5 attempts, 1s‚Üí60s max, ~123s total)
app.kafka.retry.critical.attempts=5
app.kafka.retry.critical.delay-ms=1000
app.kafka.retry.critical.multiplier=2.0
app.kafka.retry.critical.max-delay-ms=60000

# HIGH: Notifications, analytics, reporting (4 attempts, 2s‚Üí30s max, ~30s total)
app.kafka.retry.high.attempts=4
app.kafka.retry.high.delay-ms=2000
app.kafka.retry.high.multiplier=2.0
app.kafka.retry.high.max-delay-ms=30000

# NORMAL: Logging, auditing, non-critical (3 attempts, 5s‚Üí30s max, ~35s total)
app.kafka.retry.normal.attempts=3
app.kafka.retry.normal.delay-ms=5000
app.kafka.retry.normal.multiplier=2.0
app.kafka.retry.normal.max-delay-ms=30000

# BULK: Batch operations, imports (2 attempts, 10s‚Üí60s max, ~25s total)
app.kafka.retry.bulk.attempts=2
app.kafka.retry.bulk.delay-ms=10000
app.kafka.retry.bulk.multiplier=1.5
app.kafka.retry.bulk.max-delay-ms=60000

# ====== PERFORMANCE PROFILING (S8) ======

# Micrometer JVM metrics
management.metrics.enable.jvm=true
management.metrics.enable.jvm.memory=true
management.metrics.enable.jvm.gc=true
management.metrics.enable.jvm.threads=true
management.metrics.enable.jvm.classes=true

# Hibernate statistics for query profiling
spring.jpa.properties.hibernate.generate_statistics=true
spring.jpa.properties.hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS=100

# Show slow queries in logs (DEBUG level)
logging.level.org.hibernate.stat=INFO
logging.level.org.hibernate.SQL=INFO
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=INFO

# Actuator endpoints for metrics
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=when-authorized
management.endpoint.metrics.enabled=true

# Prometheus metrics export
management.metrics.export.prometheus.enabled=true
management.metrics.distribution.percentiles-histogram.http.server.requests=true

# Connection pool metrics
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.register-mbeans=true

# Performance baselines (S8)
# - Heap usage target: <70% (warning >80%, critical >90%)
# - GC pause target (p99): <100ms (warning >200ms, critical >500ms)
# - API latency (p95): <200ms (warning >500ms, critical >1000ms)
# - DB query time (avg): <50ms (warning >100ms, critical >200ms)

# ====== OPENAPI / SWAGGER DOCUMENTATION (S9) ======
# Swagger UI path: http://localhost:8080/swagger-ui.html
springdoc.api-docs.path=/api/docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.swagger-ui.tryItOutEnabled=true

# API Information
springdoc.info.title=Core Platform API
springdoc.info.description=Multi-tenant platform with user management, roles, permissions, and analytics
springdoc.info.version=1.0.0
springdoc.info.contact.name=Core Platform Team
springdoc.info.contact.email=support@core-platform.local

# Enable Actuator endpoints in OpenAPI
springdoc.show-actuator=true

# JWT Security Scheme for Swagger UI
springdoc.swagger-ui.oauth.client-id=api-docs
springdoc.swagger-ui.oauth.use-pkce-with-authorization-code-grant=true

# ====== GRAFANA PROVISIONING CONFIGURATION ======
# üöÄ Automatic Grafana organization and service account provisioning for new tenants

# Grafana Admin API connection (internal Docker network)
grafana.admin.url=${GRAFANA_ADMIN_URL:http://grafana:3000}
grafana.admin.username=${GRAFANA_ADMIN_USERNAME:admin}
grafana.admin.password=${GRAFANA_ADMIN_PASSWORD:admin}

# Provisioning settings
grafana.provisioning.enabled=${GRAFANA_PROVISIONING_ENABLED:true}
grafana.provisioning.service-account-role=${GRAFANA_SA_ROLE:Admin}

# ====== RESILIENCE4J RATE LIMITER ======
# Grafana auth_request rate limit
# High limit for dashboard auto-refresh (10s) with multiple panels
resilience4j.ratelimiter.instances.grafana-auth.limit-for-period=100
resilience4j.ratelimiter.instances.grafana-auth.limit-refresh-period=60s
resilience4j.ratelimiter.instances.grafana-auth.timeout-duration=0s

# Loki BFF API rate limit (monitoring queries)
# Prevents abuse of log query endpoints
resilience4j.ratelimiter.instances.loki-bff.limit-for-period=60
resilience4j.ratelimiter.instances.loki-bff.limit-refresh-period=60s
resilience4j.ratelimiter.instances.loki-bff.timeout-duration=0s

