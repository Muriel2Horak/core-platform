package cz.muriel.core.controller;

import cz.muriel.core.dto.UserDto;
import cz.muriel.core.auth.KeycloakAdminService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;
import software.amazon.awssdk.core.ResponseInputStream;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import software.amazon.awssdk.services.s3.model.NoSuchKeyException;

import org.springframework.beans.factory.annotation.Value;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

/**
 * üõ°Ô∏è ZABEZPEƒåEN√ù download soubor≈Ø z MinIO - Ovƒõ≈ôuje autentizaci u≈æivatele -
 * Kontroluje opr√°vnƒõn√≠ k soubor≈Øm - Future-proof pro pokroƒçil√© bezpeƒçnostn√≠
 * pravidla
 */
@Slf4j @RestController @RequestMapping("/api/files") @RequiredArgsConstructor
public class FileDownloadController {

  private final S3Client s3Client;
  private final KeycloakAdminService keycloakAdminService;

  @Value("${storage.s3.bucket-name}")
  private String bucketName;

  /**
   * üõ°Ô∏è Zabezpeƒçen√Ω download souboru - Ovƒõ≈ôuje autentizaci - Kontroluje opr√°vnƒõn√≠
   * k souboru - Podporuje r≈Øzn√© typy soubor≈Ø (avatary, dokumenty, smlouvy)
   */
  @GetMapping("/download") @PreAuthorize("isAuthenticated()")
  public ResponseEntity<?> downloadFile(@RequestParam("key") String key,
      Authentication authentication) {

    String username = getCurrentUsername(authentication);
    log.info("üîí DOWNLOAD: User {} requesting file: {}", username, key);

    try {
      // URL decode pro bezpeƒçnost
      String decodedKey = URLDecoder.decode(key, StandardCharsets.UTF_8);

      // üõ°Ô∏è BEZPEƒåNOSTN√ç KONTROLY
      if (!isUserAuthorizedForFile(decodedKey, username)) {
        log.warn("üö´ SECURITY: User {} unauthorized for file: {}", username, decodedKey);
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
            .body("Nem√°te opr√°vnƒõn√≠ k tomuto souboru");
      }

      // St√°hnout soubor z MinIO
      GetObjectRequest getObjectRequest = GetObjectRequest.builder().bucket(bucketName)
          .key(decodedKey).build();

      ResponseInputStream<GetObjectResponse> s3Object = s3Client.getObject(getObjectRequest);
      GetObjectResponse response = s3Object.response();

      // Urƒçit MIME typ
      String contentType = response.contentType();
      if (contentType == null || contentType.isEmpty()) {
        contentType = determineMimeType(decodedKey);
      }

      // Urƒçit n√°zev souboru pro download
      String filename = extractFilename(decodedKey);

      // Hlaviƒçky pro HTTP response
      HttpHeaders headers = new HttpHeaders();
      headers.setContentType(MediaType.parseMediaType(contentType));
      headers.setContentLength(response.contentLength());
      headers.setContentDispositionFormData("inline", filename);

      // Cache headers pro obr√°zky
      if (contentType.startsWith("image/")) {
        headers.setCacheControl("public, max-age=3600");
      }

      log.info("‚úÖ DOWNLOAD: Serving file {} to user {} ({})", decodedKey, username, contentType);

      return ResponseEntity.ok().headers(headers).body(new InputStreamResource(s3Object));

    } catch (NoSuchKeyException e) {
      log.warn("üìÅ FILE_NOT_FOUND: File not found: {}", key);
      return ResponseEntity.notFound().build();

    } catch (Exception e) {
      log.error("‚ùå DOWNLOAD_ERROR: Failed to download file: {}", key, e);
      return ResponseEntity.internalServerError().body("Nepoda≈ôilo se st√°hnout soubor");
    }
  }

  /**
   * üõ°Ô∏è BEZPEƒåNOSTN√ç LOGIKA - kontroluje opr√°vnƒõn√≠ k souboru Future-proof pro
   * pokroƒçil√© opr√°vnƒõn√≠ na √∫rovni entit/z√°znam≈Ø
   */
  private boolean isUserAuthorizedForFile(String key, String username) {
    try {
      // Naƒçteme u≈æivatele
      UserDto user = keycloakAdminService.getUserByUsername(username);
      String userId = user.getId();

      // üì∏ PROFILOV√â OBR√ÅZKY - vlastn√≠k nebo admin
      if (key.startsWith("profile-pictures/")) {
        return isOwnerOrAdmin(key, userId, user);
      }

      // üìÑ DOKUMENTY - budouc√≠ implementace
      if (key.startsWith("documents/")) {
        return isAuthorizedForDocument(key, userId, user);
      }

      // üìã SMLOUVY - budouc√≠ implementace
      if (key.startsWith("contracts/")) {
        return isAuthorizedForContract(key, userId, user);
      }

      // üìä REPORTY - budouc√≠ implementace
      if (key.startsWith("reports/")) {
        return isAuthorizedForReport(key, userId, user);
      }

      // Defaultnƒõ zam√≠tni p≈ô√≠stup k nezn√°m√Ωm typ≈Øm soubor≈Ø
      log.warn("üö´ UNKNOWN_FILE_TYPE: Unknown file type, denying access: {}", key);
      return false;

    } catch (Exception e) {
      log.error("üö´ AUTH_ERROR: Error checking authorization for file: {}", key, e);
      return false;
    }
  }

  /**
   * Kontrola opr√°vnƒõn√≠ pro profilov√© obr√°zky
   */
  private boolean isOwnerOrAdmin(String key, String userId, UserDto user) {
    // Profilov√© obr√°zky: profile-pictures/{userId}/avatar.ext
    if (key.startsWith("profile-pictures/" + userId + "/")) {
      log.debug("‚úÖ OWNER: User owns profile picture: {}", key);
      return true;
    }

    // Admini m≈Ø≈æou p≈ôistupovat ke v≈°em profilov√Ωm obr√°zk≈Øm
    if (user.getRoles() != null && user.getRoles().contains("CORE_ROLE_USER_MANAGER")) {
      log.debug("‚úÖ ADMIN: Admin access to profile picture: {}", key);
      return true;
    }

    log.debug("üö´ NOT_OWNER: User {} not authorized for profile picture: {}", userId, key);
    return false;
  }

  /**
   * üöÄ FUTURE: Kontrola opr√°vnƒõn√≠ pro dokumenty Zde bude implementov√°na logika
   * pro: - Vlastn√≠k dokumentu - Sd√≠len√© dokumenty - Opr√°vnƒõn√≠ podle rol√≠ -
   * Opr√°vnƒõn√≠ podle organizaƒçn√≠ struktury (manager/deputy)
   */
  private boolean isAuthorizedForDocument(String key, String userId, UserDto user) {
    // TODO: Implementovat pokroƒçilou logiku pro dokumenty
    log.info("üöÄ FUTURE: Document authorization not implemented yet: {}", key);
    return false;
  }

  /**
   * üöÄ FUTURE: Kontrola opr√°vnƒõn√≠ pro smlouvy
   */
  private boolean isAuthorizedForContract(String key, String userId, UserDto user) {
    // TODO: Implementovat pokroƒçilou logiku pro smlouvy
    log.info("üöÄ FUTURE: Contract authorization not implemented yet: {}", key);
    return false;
  }

  /**
   * üöÄ FUTURE: Kontrola opr√°vnƒõn√≠ pro reporty
   */
  private boolean isAuthorizedForReport(String key, String userId, UserDto user) {
    // TODO: Implementovat pokroƒçilou logiku pro reporty
    log.info("üöÄ FUTURE: Report authorization not implemented yet: {}", key);
    return false;
  }

  /**
   * Urƒç√≠ MIME typ na z√°kladƒõ p≈ô√≠pony souboru
   */
  private String determineMimeType(String key) {
    String lowerKey = key.toLowerCase();

    if (lowerKey.endsWith(".png"))
      return "image/png";
    if (lowerKey.endsWith(".jpg") || lowerKey.endsWith(".jpeg"))
      return "image/jpeg";
    if (lowerKey.endsWith(".gif"))
      return "image/gif";
    if (lowerKey.endsWith(".webp"))
      return "image/webp";
    if (lowerKey.endsWith(".pdf"))
      return "application/pdf";
    if (lowerKey.endsWith(".docx"))
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    if (lowerKey.endsWith(".xlsx"))
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";

    return "application/octet-stream";
  }

  /**
   * Extrahuje n√°zev souboru z cesty
   */
  private String extractFilename(String key) {
    int lastSlash = key.lastIndexOf('/');
    if (lastSlash >= 0 && lastSlash < key.length() - 1) {
      return key.substring(lastSlash + 1);
    }
    return key;
  }

  private String getCurrentUsername(Authentication authentication) {
    Jwt jwt = (Jwt) authentication.getPrincipal();
    return jwt.getClaimAsString("preferred_username");
  }
}
